## Architectural overview
This is intended as an architectural overview of this project. It covers the following topics.

- Static site generation
- Redux / Saga
- Unit testing components with [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- Bundling with [webpack](https://webpack.js.org/)
- Content management
- Styling
- Code quality checking
- CI/CD set up

### Static site generation
Over the course of this project, several iterations were implemented to facilitate server side rendering to improve loading speed.

In the end, implementing static site generation was the best course of action, given how often the content was going to be updated.

#### How it works

- The code to handle generating static content sits inside the directory [https://github.com/matfin/personal-website/tree/main/src/ssg](/src/ssg).
- A server side [<IndexComponent />](https://github.com/matfin/personal-website/blob/main/src/ssg/IndexComponent.tsx) is used with a static router to render content.
- The [<SSGController />](https://github.com/matfin/personal-website/blob/main/src/ssg/SSGController.tsx) calls to load page content using the Redux Saga set up we have, then it uses the server side `<IndexComponent />` to render it to a string with static HTML content. This static content includes `<meta />` tags for things like the title, description, OpenGraph, Twitter etc and statically rendered styles.
- Finally, there is a script in [index.ts](https://github.com/matfin/personal-website/blob/main/src/ssg/index.ts) that is bundled by webpach which handles:
  - Dynamically generating a list of slugs based on the contents of the [/pages](https://github.com/matfin/personal-website/tree/main/pages) directory.
	- Generating static content using the above mentioned `<SSGController />` and a slug as the url that needs.
	- Generating a `sitemap.xml` based on the slugs.
	- Generating a list of urls which will be used later for the [PWA](https://web.dev/progressive-web-apps/) set up.
- The end result of this is that we have directories for each part of the website with a generated `index.html` file. This is served by Nginx
- When the server side content is loaded, a JS bundle (generated by webpack) is loaded and the app is [hydrated](https://reactjs.org/docs/react-dom.html#hydrate) - see the [client side index](https://github.com/matfin/personal-website/blob/main/src/app/index.tsx).

### Redux / Saga
This app has a simple set up to manage fetching page content as the user navigates around the site. As part of the static site generation, page content will already be loaded for one page statically, but as the user navigates, content will need to be loaded again. 

For the [page redux / saga set up](https://github.com/matfin/personal-website/tree/main/src/app/services/page) there are a number of actions which tie into the saga and the reducer.

The [page saga](https://github.com/matfin/personal-website/blob/main/src/app/services/page/sagas.ts) listens out for the actions to `FETCH_PAGE` and `RESET_PAGE` and these are called directly from the [<Page />](https://github.com/matfin/personal-website/blob/main/src/app/views/page/Page.tsx) component.

The [page reducer] then handles actions dispatched with the types `FETCH_PAGE_REQUEST`, `FETCH_PAGE_SUCCESS` and `FETCH_PAGE_STARTED` and updates the reducer state, which eventually gets passed down to the page component, so that UI elements can be adjusted to match the current state (loading, failed etc).

[Abortable Fetch](https://developers.google.com/web/updates/2017/09/abortable-fetch) is also used in the [api utility](https://github.com/matfin/personal-website/blob/main/src/app/services/api/api.ts) we also have, so that a call to fetch page content can be cancelled if no longer needed. This is useful for when a user quickly navigates around and there are no unnecessary api calls in course.

### Unit testing components with React Testing Library
The preferred approach here is to keep things as simple as possible. When unit testing all components, mock data for these (component props) are declared at the top of the test file in the form of:

```
import { MyComponent, Props } from './my-component';

const defaultProps: Props = {
	isActive: true,
	fetchSomething: jest.fn()
};

describe('MyComponent tests', (): void => {
	it('should do something', (): void => {
		const { getByTestId } = render(<MyComponent {...defaultProps} />)
	});
});
```

With this approach, we can keep tests lean and override `defaultProps` if we want to add in a spy function, so as to test that it has been called with the correct parameters, for instance.

Any third party libraries that might cause issue when running with jest (that might otherwise be fine in a browser environment) are stubbed on import with [jest.mock](https://jestjs.io/docs/mock-functions).

The [tests for the `<Page />`](https://github.com/matfin/personal-website/blob/main/src/app/views/page/Page.spec.tsx) import the page component directly and not the Connected page component. This saves us from needing to wrap test components in a redux provider and test that actions were called. We don't need the added boilerplate of creating and altering mocked redux states - much cleaner tests.

### Bundling with webpack
This project uses a custom webpack set up that takes care of calling to generate static site content and update JS bundles.

- This project is written in TypeScript which is converted to JavasScript using [BabelJS](https://babeljs.io/).
- Path aliasing has been set up to make it easier to reference external dependencies, so no more `import { something } from ../../../utils/something`.
- Static content such as images, docs and robots.txt are copied on build with the [copy-webpack-plugin](https://webpack.js.org/plugins/copy-webpack-plugin/)
- The index file for static site generation [/src/ssg/index.ts](https://github.com/matfin/personal-website/blob/main/src/ssg/index.ts) is bundled so that it can later be executed by a Node environment.
- Once the client side JS bundle has been generated, a call to generate static content is made - see [webpack.dev.js](https://github.com/matfin/personal-website/blob/main/webpack.dev.js) line 13.
- [webpack-merge](https://github.com/survivejs/webpack-merge) is used to override development configs for production deployment - see [webpack.prod.js](https://github.com/matfin/personal-website/blob/main/webpack.prod.js).

### Content management
Site content is generated into HTML from JSON files stored in the [/pages](https://github.com/matfin/personal-website/tree/main/pages) directory.

When the site is statically generated (see above) these files and directories are read in and a tree of static content is generated as follows:
- `/pages/cv.json` => `/out/cv/index.html`
- `/pages/projects/ero.json` => `/out/projects/ero/index.html`

This content contains other nested content, such as sections that contain subheadings and paragraphs, images, lists that contain links etc.

The [<Page />](https://github.com/matfin/personal-website/blob/main/src/app/views/page/Page.tsx) component reads in this JSON content and then determines the correct component to render.

### Styling
This project uses CSS in JS [styled-components](https://styled-components.com/) for styling. It has the following set up.
- Global styles, mixins, colous, typography and sizes are all kept in [/src/app/styles](https://github.com/matfin/personal-website/tree/main/src/app/styles) and used throughout the project.
- The project is fully responsive and uses media queries, [CSS Grid](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout) for the main layout, and [CSS Flex](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox) for components.

### Code quality checking
- [ESLint](https://eslint.org/) and [prettier](https://prettier.io/) are used for code quality and formatting checks.
- [stylelint](https://stylelint.io/) is used to check the CSS in the styled components.

### CI/CD set up
This project uses [CircleCI](https://circleci.com/) for testing and deployment. It has the following set up.

The `test` job is run when a feature branch is pushed to (any branch other than main) and the following are checked:
- `yarn coverage` runs all tests and verifies 100% coverage.
- `yarn lint` runs all code quality checks with eslint and prettier.
- `yarn csslint` checks the css in styled components with stylelint.

The `deploy` job is run when there is a push to the main branch, normally when a PR is merged:
- The content for the site is statically generated and JS bundles are created with webpack.
- The bundle for the site is output to the `/out` directory, which is tarred and gzipped.
- This bundle is then securely copied (SCP) over to the remote server.
- A command is sent to the remote server to unbundle the contents to a directory where Nginx can find and serve them.